namespace SharpNeedle.Numerics;

// I have no idea if anything in this struct is valid, this was entirely generated by Github Copilot
public struct Ray : IIntersectable<Sphere>, IIntersectable<AABB>
{
    public Vector3 Origin;
    public Vector3 Direction;

    public Ray(Vector3 origin, Vector3 direction)
    {
        Origin = origin;
        Direction = direction;
    }

    public readonly Vector3? Intersection(AABB aabb)
    {
        float tmin = Vector3.Dot(aabb.Min - Origin, Direction);
        float tmax = Vector3.Dot(aabb.Max - Origin, Direction);
        float t1 = Math.Min(tmin, tmax);
        float t2 = Math.Max(tmin, tmax);
        if(t1 > 0 && t2 > 0)
        {
            return Origin + (Direction * t1);
        }

        return null;
    }

    public readonly Vector3? Intersection(Sphere sphere)
    {
        float a = Vector3.Dot(Direction, Direction);
        float b = 2 * Vector3.Dot(Direction, Origin - sphere.Center);
        float c = Vector3.Dot(Origin - sphere.Center, Origin - sphere.Center) - (sphere.Radius * sphere.Radius);

        float discriminant = (b * b) - (4 * a * c);

        if(discriminant < 0)
        {
            return null;
        }

        float t = (-b - MathF.Sqrt(discriminant)) / (2 * a);

        return Origin + (Direction * t);
    }

    public readonly bool Intersects(Sphere sphere)
    {
        float a = Vector3.Dot(Direction, Direction);
        float b = 2 * Vector3.Dot(Direction, Origin - sphere.Center);
        float c = Vector3.Dot(Origin - sphere.Center, Origin - sphere.Center) - (sphere.Radius * sphere.Radius);

        float discriminant = (b * b) - (4 * a * c);

        return discriminant >= 0;
    }

    public readonly bool Intersects(AABB aabb)
    {
        float tmin = Vector3.Dot(aabb.Min - Origin, Direction) / Vector3.Dot(Direction, Direction);
        float tmax = Vector3.Dot(aabb.Max - Origin, Direction) / Vector3.Dot(Direction, Direction);

        if(tmin > tmax)
        {
            (tmin, tmax) = (tmax, tmin);
        }

        return tmin <= tmax;
    }

    public readonly Vector3 PointAt(float t)
    {
        return Origin + (t * Direction);
    }
}